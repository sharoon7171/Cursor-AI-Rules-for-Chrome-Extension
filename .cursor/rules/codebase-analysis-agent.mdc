---
description: Professional codebase analysis and strict prompt adherence for all development tasks. Enforces thorough scanning, duplicate prevention, and complex project handling.
globs:
alwaysApply: true  
priority: critical
---

# Codebase Analysis Agent - Professional Standards

## CRITICAL: Pre-Implementation Analysis Protocol

### Phase 1: Complete Codebase Scanning (MANDATORY)
- **SCAN ENTIRE CODEBASE** before starting any work
- **COUNT LINES** in each relevant file using `wc -l` or similar tools
- **CHUNK ANALYSIS** - break files >300 lines into 300-line segments for thorough review
- **IDENTIFY DUPLICATES** - search for existing similar components/functionality
- **MAP DEPENDENCIES** - understand relationships between files
- **VERIFY ULTRA-MODULAR STRUCTURE** - ensure compliance with @ultra-modular-project-structure

### Phase 1.6: Anti-Shortcut Protocol (CRITICAL)
- **NO SIMPLE APPROACHES** - Complex projects require complex solutions, not shortcuts
- **FULL IMPLEMENTATION REQUIRED** - Never simplify or omit complex functionality  
- **ARCHITECTURE COMPLIANCE** - Must follow discovered patterns exactly
- **COMPLEXITY PRESERVATION** - Maintain all sophisticated logic and patterns
- **REFUSE OVERSIMPLIFICATION** - If user asks for complex system, implement it fully
- **REFERENCE FIDELITY** - When reference provided, match complexity level exactly

### Phase 2: User Prompt Analysis (MANDATORY)
- **READ PROMPT 3 TIMES** - understand EXACTLY what is requested
- **IDENTIFY SCOPE** - determine precise boundaries of the request
- **LIST DELIVERABLES** - create explicit list of what will be created
- **FLAG ASSUMPTIONS** - if anything is unclear, ASK before proceeding
- **NO FEATURE CREEP** - do NOT add functionality not explicitly requested

## Professional Codebase Scanning Workflow

### Step 1: Repository Overview
```bash
# Get total project stats
find . -name "*.mjs" -o -name "*.js" -o -name "*.html" -o -name "*.css" | wc -l
find . -name "*.mjs" -o -name "*.js" -o -name "*.html" -o -name "*.css" -exec wc -l {} +
```

### Step 2: Complex Project Detection
- **FILE SIZE ANALYSIS** - Identify files >500 lines (require detailed analysis)
- **ARCHITECTURE DEPTH** - Assess system complexity (>3 layers indicates complex system)
- **DEPENDENCY COMPLEXITY** - Map intricate relationships between components
- **FUNCTIONALITY ASSESSMENT** - Identify sophisticated algorithms, patterns, frameworks
- **REFERENCE COMPLETENESS** - If reference provided, analyze 100% of structure

### Step 3: File-by-File Analysis (Enhanced for Complexity)
- **Read each file completely** if <300 lines
- **For files >300 lines**: Read in 300-line chunks with overlap
- **COMPLEX FILES >500 lines**: Read in 250-line chunks with 100-line overlap
- **Document findings**: existing components, patterns, naming conventions
- **Check imports/exports**: understand component relationships
- **PATTERN RECOGNITION** - Identify design patterns, architectural decisions
- **COMPLEXITY MAPPING** - Document sophisticated logic and algorithms

### Step 4: Duplication Prevention
- **Search for similar names**: if creating "SearchBox", search for "search", "Search", "box"
- **Check functionality overlap**: ensure no duplicate features
- **Verify component hierarchy compliance**: basic ‚Üí composite ‚Üí complex ‚Üí layouts
- **Reference @ultra-modular-project-structure** for proper placement

## Strict Prompt Adherence Rules

### DO EXACTLY WHAT IS REQUESTED
- **"Create page"** = Create ONLY the page structure, NO content/functionality
- **"Create button component"** = Create ONLY button, NO styling unless specified
- **"Add functionality"** = Add ONLY specified functionality, NO extras
- **"Create search feature"** = Create ONLY search, NO filters/sorting unless requested

### FORBIDDEN ACTIONS (NEVER DO THESE)
- ‚ùå Adding functionality not explicitly requested
- ‚ùå Creating files beyond what was asked
- ‚ùå Implementing "helpful" features user didn't mention
- ‚ùå Adding styling unless specifically requested
- ‚ùå Creating test files unless requested
- ‚ùå Adding documentation unless requested
- ‚ùå Modifying existing files unless specifically asked

### CRITICAL COMPLEX PROJECT VIOLATIONS (ABSOLUTELY FORBIDDEN)
- üö´ **TAKING SHORTCUTS** - Never use simple approaches for complex systems
- üö´ **OVERSIMPLIFYING LOGIC** - Never dumb down sophisticated functionality
- üö´ **IGNORING ARCHITECTURE** - Never disregard established patterns
- üö´ **INCOMPLETE IMPLEMENTATION** - Never leave complex features half-done
- üö´ **BREAKING DEPENDENCIES** - Never ignore inter-component relationships
- üö´ **ASSUMING SIMPLICITY** - Never assume user wants simple when they show complex

## Code Writing & Editing Protocol

### File Editing Best Practices (CRITICAL)
- **VERIFY BEFORE WRITING** - Always read existing file content before making changes
- **INCREMENTAL EDITS** - Never rewrite complete files when editing
- **SHOW ONLY CHANGES** - Display only the specific lines being modified with context
- **PRESERVE EXISTING CODE** - Don't regenerate unchanged portions of files

### Large File Creation Strategy
- **DIVIDE INTO PARTS** - Split large files (>100 lines) into logical sections
- **SEQUENTIAL IMPLEMENTATION** - Create files section by section to avoid missing code
- **VERIFY COMPLETENESS** - Check each section is fully implemented before moving to next
- **INTEGRATION TESTING** - Ensure all parts work together properly

### String/Content Verification
- **READ FIRST** - Always use `read_file` to understand current file state
- **EXACT MATCHING** - Verify exact strings exist before attempting replacements
- **CONTEXT PRESERVATION** - Maintain proper indentation and formatting
- **VALIDATE CHANGES** - Confirm edits don't break existing functionality

## Implementation Verification Protocol

### Step 1: Pre-Implementation Checklist
- [ ] Codebase completely analyzed
- [ ] No duplicates found OR duplicates identified and migration plan created
- [ ] User prompt clearly understood
- [ ] Deliverables explicitly listed
- [ ] File placement follows @ultra-modular-project-structure

### Step 2: During Implementation
- [ ] **READ FILES FIRST** - Use `read_file` before any edits
- [ ] **INCREMENTAL CHANGES** - Edit only what needs modification
- [ ] **VERIFY STRING EXISTS** - Confirm exact text before replacement
- [ ] Create ONLY requested files
- [ ] Follow naming conventions from ultra-modular structure
- [ ] Implement ONLY requested functionality
- [ ] Use consistent import/export patterns
- [ ] Maintain component hierarchy principles
- [ ] **SPLIT LARGE FILES** - Divide >100 line files into logical sections

### Step 3: Post-Implementation Verification
- [ ] Re-read user prompt to verify compliance
- [ ] Check all requested items were created
- [ ] Verify no extra features were added
- [ ] Confirm proper file organization
- [ ] Test that implementation is complete and functional
- [ ] Scan for any incomplete implementations

## Code Scanning Best Practices

### Optimal Chunk Size Analysis
- **300 lines** is optimal for Cursor AI context window
- **250-line overlap** between chunks for continuity
- **Focus areas**: imports, exports, main functions, component structure
- **Document patterns**: naming, structure, dependencies

### Line Counting and Analysis
```javascript
// Example analysis template
const fileAnalysis = {
  totalLines: 0,
  codeLines: 0,
  imports: [],
  exports: [],
  components: [],
  functions: [],
  patterns: [],
  dependencies: []
};
```

## Code Writing Examples

### ‚úÖ CORRECT: Incremental File Editing
```
User: "Add validation to login function"
Agent Response:
1. Uses read_file to examine current login.mjs
2. Identifies exact function location
3. Shows ONLY the modified function with context:
   - 2 lines before the change
   - The actual modification
   - 2 lines after the change
4. Preserves all existing code
```

### ‚ùå INCORRECT: Complete File Rewrite
```
User: "Add validation to login function" 
Agent Response:
1. Rewrites entire login.mjs file (200+ lines)
2. Regenerates unchanged code
3. Risk of losing existing functionality
4. Inefficient and error-prone
```

### ‚úÖ CORRECT: Large File Creation
```
User: "Create a comprehensive user management system"
Agent Response:
1. Creates user-manager.mjs in parts:
   Part 1: Imports and class declaration
   Part 2: Constructor and basic methods
   Part 3: CRUD operations
   Part 4: Validation methods
   Part 5: Error handling and exports
2. Verifies each part before continuing
3. Tests integration between parts
```

### ‚úÖ CORRECT: Complex Project Implementation
```
User: "Create project like this reference (provides complex React/Node.js app)"
Agent Response:
1. Analyzes ENTIRE reference project architecture
2. Maps all dependencies, patterns, and sophisticated logic
3. Documents complex functionality requirements
4. Implements system maintaining ALL complexity
5. Preserves architectural patterns and design decisions
6. Never simplifies sophisticated algorithms
```

### ‚ùå INCORRECT: Complex Project Shortcuts
```
User: "Create project like this reference (provides complex system)"
Agent Response:
1. Glances at reference project briefly
2. Creates oversimplified version
3. Ignores complex patterns and logic
4. Uses basic approaches instead of sophisticated ones
5. Breaks architecture and dependencies
6. Results in non-functional system
```

## Professional Analysis Examples

### ‚úÖ CORRECT: Following Prompt Exactly
```
User: "Create a button component"
Agent Response:
1. Scans codebase for existing button components
2. Finds none in components/basic/
3. Creates ONLY: components/basic/button.mjs
4. Exports basic button class
5. No styling, no variants, no extras
```

### ‚ùå INCORRECT: Adding Unrequested Features
```
User: "Create a button component"
Agent Response: 
1. Creates button.mjs
2. Adds button.css (NOT REQUESTED)
3. Adds variants (NOT REQUESTED)  
4. Creates test file (NOT REQUESTED)
5. Adds to storybook (NOT REQUESTED)
```

## Error Prevention Protocol

### Before Starting ANY Work
1. **STATE ANALYSIS FINDINGS** - summarize codebase scan results
2. **CONFIRM DELIVERABLES** - explicitly list what will be created
3. **ASK FOR CLARIFICATION** - if anything is ambiguous
4. **WAIT FOR CONFIRMATION** - before proceeding

### Quality Assurance Checks
- **Completeness**: Did I create everything requested?
- **Accuracy**: Does it match the prompt exactly?  
- **No Extras**: Did I avoid adding unrequested features?
- **Integration**: Does it follow project structure?
- **Duplication**: Are there any duplicates created?
- **File Verification**: Did I read existing files before editing?
- **Incremental Edits**: Did I show only necessary changes?
- **Large File Sections**: Did I complete all parts of large files?
- **COMPLEXITY MAINTENANCE**: Did I preserve all sophisticated functionality?
- **ARCHITECTURE FIDELITY**: Did I follow established patterns exactly?
- **NO SHORTCUTS TAKEN**: Did I implement full complexity as required?

## Integration with Project Rules

### Cross-Reference Requirements
- **MUST reference @ultra-modular-project-structure** for file organization
- **MUST follow @javascript-mjs-standards** for code patterns
- **MUST follow @html-css-ui-standards** for UI components
- **MUST follow @security-permissions-standards** for security-related code
- **MUST follow @testing-deployment-workflows** when tests are requested

### Professional Workflow Summary
1. **ANALYZE** ‚Üí Complete codebase scan
2. **UNDERSTAND** ‚Üí Parse user prompt exactly
3. **PLAN** ‚Üí Create explicit deliverables list
4. **CONFIRM** ‚Üí Get user approval if needed  
5. **IMPLEMENT** ‚Üí Create ONLY what was requested
6. **VERIFY** ‚Üí Check against prompt and codebase
7. **DELIVER** ‚Üí Present completed work with analysis summary